using System.Collections.Generic;
using System.Linq;
using SabberStoneCore.Tasks;
using SabberStoneCore.Enums;
using SabberStoneCore.Kettle;
using SabberStoneCore.Model.Entities;
using SabberStoneCore.Model.Entities.Playables;

namespace SabberStoneCore.Model
{
	/// <summary>
	/// Holds all tasks which are awaiting processing by <see cref="Model.Game.DeathProcessingAndAuraUpdate"/>.
	/// The <see cref="ISimpleTask"/>s stored in this queue are generated by effects
	/// of parent <see cref="ISimpleTask"/>s.
	/// </summary>
	public class TaskQueue
    {
        private List<ISimpleTask> TaskList = new List<ISimpleTask>();

		/// <summary>Gets the amount of tasks stored inside the queue.</summary>
		/// <value>The queue item count.</value>
		public int Count => TaskList.Count;

		/// <summary>Gets the game which owns this queue.</summary>
		/// <value><see cref="Model.Game"/></value>
		public Game Game { get; }

		/// <summary>Gets or sets the current task.</summary>
		/// <value><see cref="ISimpleTask"/></value>
		public ISimpleTask CurrentTask { get; private set; }

		/// <summary>Initializes a new instance of the <see cref="TaskQueue"/> class.</summary>
		/// <param name="game">The game.</param>
		/// <autogeneratedoc />
		public TaskQueue(Game game)
        {
            Game = game;
        }

		/// <summary>Immediately executes specified task, with specified arguments.</summary>
		/// <param name="task">The task.</param>
		/// <param name="controller">The controller.</param>
		/// <param name="source">The source.</param>
		/// <param name="target">The target.</param>
		public void Execute(ISimpleTask task, Controller controller, IPlayable source, IPlayable target)
        {
            var clone = task.Clone();
            clone.Game = controller.Game;
            clone.Controller = controller;
            clone.Source = source;
            clone.Target = target;
            Game.Log(ELogLevel.VERBOSE, EBlockType.TRIGGER, "TaskQueue", $"PriorityTask[{clone.Source}]: '{clone.GetType().Name}' is processed!" +
                     $"'{clone.Source.Card.Text?.Replace("\n", " ")}'");

            // power block
            if (controller.Game.HistoryEnabled)
                controller.Game.PowerHistory.Add(PowerHistoryBuilder.BlockStart(EBlockType.POWER, source.Id, "", -1, target?.Id ?? 0));

            clone.Process();

            if (controller.Game.HistoryEnabled)
                controller.Game.PowerHistory.Add(PowerHistoryBuilder.BlockEnd());

            Game.TaskStack.Reset();
        }

        /// <summary>
        /// Enqueue tasks that will be proccess by the DeathAndAuraProcessing.
        /// IMPORTANT: only enqueue cloned tasks ....
        /// </summary>
        /// <param name="task"></param>
        public void Enqueue(ISimpleTask task)
        {
            // TODO ... check if necessary ... frothing beserker ... check for duplicates, ex. auras
            //if (_lazyTaskQueue.Contains(task))
            //    return;

            // TODO reset task from previous uses .. maybee need to clone it?
            //task.Reset();

            TaskList.Add(task);
        }

		/// <summary>Processes the next pending task, stored within this queue.</summary>
		/// <returns></returns>
		public ETaskState Process()
        {
            CurrentTask = TaskList.OrderBy(p => p.Source.OrderOfPlay).First();
            TaskList.Remove(CurrentTask);
            Game.Log(ELogLevel.VERBOSE, EBlockType.TRIGGER, "TaskQueue", $"LazyTask[{CurrentTask.Source}]: '{CurrentTask.GetType().Name}' is processed!" +
                                        $"'{CurrentTask.Source.Card.Text?.Replace("\n", " ")}'");


            // power block
            if (Game.HistoryEnabled)
                Game.PowerHistory.Add(PowerHistoryBuilder.BlockStart(EBlockType.POWER, CurrentTask.Source.Id, "", -1, CurrentTask.Target?.Id ?? 0));

            var success = CurrentTask.Process();

            if (Game.HistoryEnabled)
                Game.PowerHistory.Add(PowerHistoryBuilder.BlockEnd());

            // reset between task execution
            Game.TaskStack.Reset();

            //if (Game.Splits.Count == 0 && CurrentTask.Splits != null && CurrentTask.Splits.Count > 0)
            //{
            //    Log.Info($"Parallel-threading splits '{CurrentTask.Splits.Count}' starting now! [Info: {Game.Splits.Count}]");
            //    Game.Splits = CurrentTask.Splits;                
            //}
            return success;
        }

		/// <summary>Copy internal data from the provided object into this one.</summary>
		/// <param name="other">The other <see cref="TaskQueue"/> instance.</param>
		public void Stamp(TaskQueue other)
		{
			TaskList = new List<ISimpleTask>();
			other.TaskList.ForEach(p => TaskList.Add(p.Clone()));
			if (other.CurrentTask != null)
			{
				CurrentTask = other.CurrentTask.Clone();
				CurrentTask.Game = Game;
			}
			TaskList.ForEach(p =>
			{
				p.Game = Game;
				//p.Reset();
			});
		}
	}
}

using System.Collections.Generic;
using System.Linq;
using SabberStoneCore.Enums;
using SabberStoneCore.Enchants;
using SabberStoneCore.Model.Zones;

namespace SabberStoneCore.Model.Entities.Playables
{
	/// <summary>
	/// Default implementation of <see cref="IPlayable"/>.
	/// This class represents all entities which can be 'played', which means
	/// the entity can be moved from <see cref="HandZone"/> into another <see cref="IZone"/>.
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <seealso cref="Targeting" />
	/// <seealso cref="IPlayable" />
	public abstract partial class Playable<T> : Targeting, IPlayable where T : Entity
	{
		#region PROPERTIES
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public IPlayable[] ChooseOnePlayables { get; } = new IPlayable[2];

		public List<Enchantment> Enchantments { get; set; } = new List<Enchantment>();

		public virtual bool IsPlayable => IsPlayableByController && IsPlayableByCardReq;

		public virtual bool IsPlayableByController => IsPlayableTestController();

		public virtual bool IsPlayableByCardReq => IsPlayableTestCardRequirements();

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
		#endregion

		/// <summary>Initializes a new instance of the <see cref="Playable{T}"/> class.</summary>
		/// <param name="controller">The controller.</param>
		/// <param name="card">The card.</param>
		/// <param name="tags">The tags.</param>
		/// <autogeneratedoc />
		protected Playable(Controller controller, Card card, Dictionary<EGameTag, int> tags)
			: base(controller, card, tags)
		{

			if (Card.Enchantments != null)
			{
				Enchantments.AddRange(Card.Enchantments);
			}
		}


#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public virtual void ApplyEnchantments(EEnchantmentActivation activation, EZone zoneType, IPlayable target = null)
		{
			var removeEnchantments = new List<Enchantment>();

			Enchantments.ForEach(p =>
			{
				if (p.Activation == activation && (Zone == null || Zone.Type == zoneType))
				{
					p.Activate(Controller, this, target);
					if (p.RemoveAfterActivation)
					{
						removeEnchantments.Add(p);
					}
				}
			});

			removeEnchantments.ForEach(p => Enchantments.Remove(p));
		}
		
		public void SetOrderOfPlay(ECardType card)
		{
			if (card == ECardType.WEAPON || card == ECardType.SPELL || card == ECardType.MINION)
			{
				OrderOfPlay = Game.NextOrderOfPlayIdx;
			}
		}
		
		public IPlayable Destroy()
		{
			ToBeDestroyed = true;
			Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"{this} just got set to be destroyed.");
			return this;
		}


		private bool IsPlayableTestController()
		{
			// check if player is on turn
			if (Controller != Game.CurrentPlayer)
			{
				Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable",
					$"{this} isn't playable, because player not on turn.");
				return false;
			}

			// check if entity is in hand to be played
			if (Zone != Controller.Hand && !(this is HeroPower))
			{
				Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable",
					$"{this} isn't playable, because card not in hand.");
				return false;
			}

			// check if player has enough mana to play card
			if (Controller.RemainingMana < Cost)
			{
				Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable",
					$"{this} isn't playable, because not enough mana to pay cost.");
				return false;
			}

			// check if we got a slot on board for minions
			if (Controller.Board.IsFull && this is Minion)
			{
				Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable",
					$"{this} isn't playable, because not enough place on board.");
				return false;
			}

			// check if we can play this secret
			var spell = this as Spell;
			if (spell != null && spell.IsSecret && Controller.Secrets.GetAll.Exists(p => p.Card.Id == spell.Card.Id))
			{
				Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable",
					$"{this} isn't playable, because secret already active on controller.");
				return false;
			}

			return true;
		}


		private bool IsPlayableTestCardRequirements()
		{
			// check if we need a target and there are some
			if (Card.RequiresTarget && !ValidPlayTargets.Any())
			{
				Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"{this} isn't playable, because need valid target and we don't have one.");
				return false;
			}

			// check requirments on cards here 
			foreach (KeyValuePair<EPlayReq, int> item in Card.PlayRequirements)
			{
				EPlayReq req = item.Key;
				int param = item.Value;

				Game.Log(ELogLevel.DEBUG, EBlockType.PLAY, "Playable", $"{this} check PlayReq {req} ... !");

				switch (req)
				{
					case EPlayReq.REQ_NUM_MINION_SLOTS:
						if (Controller.Board.IsFull)
						{
							Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"Board is full can't summon new minion.");
							return false;
						}
						break;
					case EPlayReq.REQ_ENTIRE_ENTOURAGE_NOT_IN_PLAY:
						var ids = Controller.Board.GetAll.Select(p => p.Card.Id).ToList();
						bool containsAll = true;
						Card.Entourage.ForEach(p => containsAll &= ids.Contains(p));
						if (containsAll)
						{
							Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"All ready all entourageing cards summoned.");
							return false;
						}
						break;
					case EPlayReq.REQ_WEAPON_EQUIPPED:
						if (Controller.Hero.Weapon == null)
						{
							Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"Need a weapon to play this card.");
							return false;
						}
						break;
					case EPlayReq.REQ_MINIMUM_ENEMY_MINIONS:
						if (Controller.Opponent.Board.Count < param)
						{
							Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"Need at least {param} enemy minions to play this card.");
							return false;
						}
						break;
					case EPlayReq.REQ_MINIMUM_TOTAL_MINIONS:
						if (Controller.Board.Count + Controller.Opponent.Board.Count < param)
						{
							Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"Need at least {param} minions to play this card.");
							return false;
						}
						break;
					case EPlayReq.REQ_STEADY_SHOT:
						if (!Controller.Hero.Power.Card.Id.Equals("DS1h_292"))
						{
							Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"Need steady shoot to be used.");
							return false;
						}
						break;

					case EPlayReq.REQ_FRIENDLY_MINION_DIED_THIS_GAME:
						if (!Controller.Graveyard.GetAll.Exists(p => p is Minion))
						{
							Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Playable", $"No friendly minions died this game.");
							return false;
						}
						break;

					// implemented in Targeting
					case EPlayReq.REQ_TARGET_FOR_COMBO:
					case EPlayReq.REQ_FROZEN_TARGET:
					case EPlayReq.REQ_MINION_OR_ENEMY_HERO:
					case EPlayReq.REQ_TARGET_MAX_ATTACK:
					case EPlayReq.REQ_MINION_TARGET:
					case EPlayReq.REQ_FRIENDLY_TARGET:
					case EPlayReq.REQ_ENEMY_TARGET:
					case EPlayReq.REQ_UNDAMAGED_TARGET:
					case EPlayReq.REQ_DAMAGED_TARGET:
					case EPlayReq.REQ_TARGET_WITH_RACE:
					case EPlayReq.REQ_MUST_TARGET_TAUNTER:
					case EPlayReq.REQ_TARGET_MIN_ATTACK:
					case EPlayReq.REQ_TARGET_WITH_DEATHRATTLE:
					case EPlayReq.REQ_TARGET_WITH_BATTLECRY:
					case EPlayReq.REQ_TARGET_IF_AVAILABLE_AND_DRAGON_IN_HAND:
					case EPlayReq.REQ_TARGET_IF_AVAILABE_AND_ELEMENTAL_PLAYED_LAST_TURN:
					case EPlayReq.REQ_TARGET_IF_AVAILABLE_AND_MINIMUM_FRIENDLY_MINIONS:
					case EPlayReq.REQ_TARGET_IF_AVAILABLE_AND_MINIMUM_FRIENDLY_SECRETS:
					case EPlayReq.REQ_NONSELF_TARGET:
						break;

					// already implemented ... card.RequiresTarget and RequiresTargetIfAvailable
					case EPlayReq.REQ_TARGET_TO_PLAY:
					case EPlayReq.REQ_TARGET_IF_AVAILABLE:
						break;

					default:
						Game.Log(ELogLevel.ERROR, EBlockType.PLAY, "Playable", $"PlayReq {req} not in switch needs to be added (Playable)!");
						break;
				}
			}

			return true;
		}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	}
}
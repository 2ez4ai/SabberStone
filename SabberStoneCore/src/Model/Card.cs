using System.Collections.Generic;
using System.Linq;
using System.Text;
using SabberStoneCore.Enchants;
using SabberStoneCore.Enums;
using SabberStoneCore.Loader;
using System;

namespace SabberStoneCore.Model
{
	/// <summary>
	/// Object representing a known entity.
	/// 
	/// All properties exposed by these instances are defined by `resources/Data/CardDefs.xml`.
	/// <see cref="CardLoader"/> for extraction procedures.
	/// </summary>
	public sealed class Card
	{
		public int AssetId { get; set; }

		/// <summary>
		/// Unique card ID, as defined in 
		/// </summary>
		public string Id { get; set; }

		/// <summary>
		/// Name of the card, localized in the extracted language.
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// Flavour text of the card, localized in the extracted language.
		/// </summary>
		public string Text { get; set; }

		/// <summary>
		/// Contains all card ID's which are generated by this specific card.
		/// 
		/// For example Ysera, the dragon which produces on DREAM card after your turn,
		/// has entourage: DREAM_01, DREAM_02, DREAM_03, DREAM_04, DREAM_05
		/// </summary>
		public List<string> Entourage { get; set; }

		/// <summary>
		/// Properties set on this instance.
		/// These properties represent health, attack, # turns in play etc.
		/// <see cref="EGameTag"/> for all possibilities.
		/// </summary>
		public Dictionary<EGameTag, int> Tags { get; set; }

		/// <summary>
		/// Declares all effects that are triggered by this instance.
		/// Possibilities are SpellPower, DeathRattle, Charge etc.
		/// </summary>
		public Dictionary<EGameTag, int> RefTags { get; set; }

		/// <summary>
		/// Requirements that must have been met before this card can be moved into 
		/// play zone.
		/// <see cref="EPlayReq"/> for all possibilities.
		/// </summary>
		public Dictionary<EPlayReq, int> PlayRequirements { get; set; }

		/// <summary>
		/// Provides easy access to the value of a specific Tag set on this instance.
		/// <seealso cref="Tags"/>
		/// </summary>
		/// <param name="t">The <see cref="EGameTag"/> which value is queried</param>
		/// <returns></returns>
		public int this[EGameTag t] => Tags.ContainsKey(t) ? Tags[t] : 0;

		/// <summary>
		/// Indicates if this card occurs in the player's collection. Only collectible
		/// cards can be put together in a deck.
		/// 
		/// Non-collectible cards are generated during the game, like Ysera's Dream cards.
		/// </summary>
		public bool Collectible => this[EGameTag.COLLECTIBLE] == 1;

		/// <summary>
		/// A card can have NO class or AT MOST one.
		/// The cardclass is coupled with the chosen hero to represent the player.
		/// 
		/// Cards with a specific class can NOT be put into a deck with other classcards.
		/// <seealso cref="ECardClass"/>
		/// </summary>
		public ECardClass Class => (ECardClass)this[EGameTag.CLASS];

		/// <summary>
		/// <see cref="Race"/>
		/// </summary>
		public ERace Race => (ERace)this[EGameTag.CARDRACE];

		/// <summary>
		/// <see cref="Faction"/>
		/// </summary>
		public EFaction Faction => (EFaction)this[EGameTag.FACTION];

		/// <summary>
		/// Indicates if this card has a combo effect or not.
		/// </summary>
		public bool HasCombo => this[EGameTag.COMBO] == 1;

		/// <summary>
		/// <see cref="Rarity"/>
		/// </summary>
		public ERarity Rarity => (ERarity)this[EGameTag.RARITY];

		/// <summary>
		/// The actual type of a card has limitations on it's usage.
		/// A hero card cannot be put into a deck for example.. imagine that!
		/// 
		/// <see cref="ECardType"/>
		/// </summary>
		public ECardType Type => (ECardType)this[EGameTag.CARDTYPE];

		/// <summary>
		/// <see cref="ECardSet"/>
		/// </summary>
		public ECardSet Set => (ECardSet)this[EGameTag.CARD_SET];

		/// <summary>
		/// Original mana-cost of this card.
		/// </summary>
		public int Cost => this[EGameTag.COST];

		/// <summary>
		/// True if this card will incur Overload when played.
		/// 
		/// Overload is an effect that locks mana crystals.
		/// Locked mana crystals can't be spent during one turn.
		/// </summary>
		public bool HasOverload => this[EGameTag.OVERLOAD] == 1;

		/// <summary>
		/// The amount of overload incurred by this card when played.
		/// </summary>
		public int Overload => this[EGameTag.OVERLOAD_OWED];

		/// <summary>
		/// Returns to which multi class group this card belongs.
		/// <see cref="EMultiClassGroup"/>
		/// </summary>
		public EMultiClassGroup MultiClassGroupType => (EMultiClassGroup)this[EGameTag.MULTI_CLASS_GROUP];


#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public bool RequiresTarget => PlayRequirements.ContainsKey(EPlayReq.REQ_TARGET_TO_PLAY);

		public bool RequiresTargetForCombo => PlayRequirements.ContainsKey(EPlayReq.REQ_TARGET_FOR_COMBO);

		public bool RequiresTargetIfAvailable => PlayRequirements.ContainsKey(EPlayReq.REQ_TARGET_IF_AVAILABLE);

		public bool RequiresTargetIfAvailableAndDragonInHand
			=> PlayRequirements.ContainsKey(EPlayReq.REQ_TARGET_IF_AVAILABLE_AND_DRAGON_IN_HAND);

		public bool RequiresTargetIfAvailableAndElementalPlayedLastTurn
			=> PlayRequirements.ContainsKey(EPlayReq.REQ_TARGET_IF_AVAILABE_AND_ELEMENTAL_PLAYED_LAST_TURN);

		public bool RequiresTargetIfAvailableAndMinimumFriendlyMinions
			=> PlayRequirements.ContainsKey(EPlayReq.REQ_TARGET_IF_AVAILABLE_AND_MINIMUM_FRIENDLY_MINIONS);

		public bool RequiresTargetIfAvailableAndMinimumFriendlySecrets
			=> PlayRequirements.ContainsKey(EPlayReq.REQ_TARGET_IF_AVAILABLE_AND_MINIMUM_FRIENDLY_SECRETS);

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

		/// <summary>
		/// Maximum amount of copies that are allowed in one deck.
		/// </summary>
		public int MaxAllowedInDeck => Rarity == ERarity.LEGENDARY ? 1 : 2;

		/// <summary>
		/// True if the effects of this card are implemented.
		/// </summary>
		public bool Implemented { get; set; }

		/// <summary>
		/// Holds a list of Buffs/Debuffs on this card instance.
		/// <seealso cref="Enchantment"/>
		/// </summary>
		public List<Enchantment> Enchantments { get; set; } = new List<Enchantment>();

		/// <summary>
		/// True if this card increases it's owners spell damage.
		/// </summary>
		public bool BringsSpellDamage { get; set; }

		/// <summary>
		/// <see cref="Object.ToString"/>
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return $"[{Name}]";
		}

		/// <summary>
		/// Returns a substring of the name of this instance.
		/// </summary>
		/// <param name="size">The maximum length of the substring in # characters.</param>
		/// <returns></returns>
		public string AbbreviatedName(int size)
		{
			if (Name.Length <= size)
			{
				return Name;
			}
			else if (!Name.Contains(" "))
			{
				return Name.Substring(0, size);
			}
			else
			{
				string[] strArray = Name.Split(' ');
				return String.Join("", strArray.Select(p => p.Length > 4 ? p.Substring(0, 4) : p).ToList()).Substring(0, 7);
			}

		}

		/// <summary>
		/// Returns a string containing all information about this instance.
		/// </summary>
		/// <param name="gameTag"></param>
		/// <param name="playReq"></param>
		/// <returns></returns>
		public string FullPrint(bool gameTag = false, bool playReq = false)
		{
			var builder = new StringBuilder();
			builder.Append($"[CARD: {Name} - {Id} (Col={Collectible},Set={Set})]");
			if (gameTag)
			{
				builder.Append("\n   GameTags:");
				Tags.ToList().ForEach(pair => builder.Append($"\n   - {pair.Key} -> {pair.Value}"));
			}
			if (playReq)
			{
				builder.Append("\n   PlayReq:");
				PlayRequirements.ToList().ForEach(pair => builder.Append($"\n   - {pair.Key} -> {pair.Value}"));
			}
			return builder.ToString();
		}

		internal static Card CardGame => new Card()
		{
			Id = "Game",
			Name = "Game",
			Tags = new Dictionary<EGameTag, int> { [EGameTag.CARDTYPE] = (int)ECardType.GAME },
			PlayRequirements = new Dictionary<EPlayReq, int>(),
		};

		internal static Card CardPlayer => new Card()
		{
			Id = "Player",
			Name = "Player",
			Tags = new Dictionary<EGameTag, int> { [EGameTag.CARDTYPE] = (int)ECardType.PLAYER },
			PlayRequirements = new Dictionary<EPlayReq, int>(),
		};
	}
}

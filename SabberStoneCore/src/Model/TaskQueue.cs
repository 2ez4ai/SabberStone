using SabberStoneCore.Enums;
using SabberStoneCore.Kettle;
using SabberStoneCore.Model.Entities;
using SabberStoneCore.Tasks;
using System.Collections.Generic;
using System.Linq;

using InternalTaskModel = System.Collections.Generic.KeyValuePair<int, SabberStoneCore.Tasks.ISimpleTask>;

namespace SabberStoneCore.Model
{

	/// <summary>
	/// Holds all tasks which are awaiting processing by <see cref="Model.Game.DeathProcessingAndAuraUpdate"/>.
	/// The <see cref="ISimpleTask"/>s stored in this queue are generated by effects
	/// of parent <see cref="ISimpleTask"/>s.
	/// </summary>	
	public class TaskQueue
	{
		private readonly SortedList<int, ISimpleTask> _internalList;

		/// <summary>Gets the amount of tasks stored inside the queue.</summary>
		/// <value>The queue item count.</value>
		public int Count => _internalList.Count;

		/// <summary>Gets the game which owns this queue.</summary>
		/// <value><see cref="Model.Game"/></value>
		public Game Game { get; }

		/// <summary>Gets or sets the current task.</summary>
		/// <value><see cref="ISimpleTask"/></value>
		public ISimpleTask CurrentTask { get; private set; }

		/// <summary>Initializes a new instance of the <see cref="TaskQueue"/> class.</summary>
		/// <param name="game">The game.</param>
		/// <autogeneratedoc />
		public TaskQueue(Game game)
		{
			_internalList = new SortedList<int, ISimpleTask>(10);
			Game = game;
		}

		/// <summary>Immediately executes the specified task, with specified arguments.</summary>
		/// <param name="task">The task.</param>
		/// <param name="controller">The controller.</param>
		/// <param name="source">The source.</param>
		/// <param name="target">The target.</param>
		public void Execute(ISimpleTask task, Controller controller, IPlayable source, IPlayable target)
		{
			ISimpleTask clone = task.Clone();
			clone.Game = controller.Game;
			clone.Controller = controller;
			clone.Source = source;
			clone.Target = target;
			Game.Log(ELogLevel.VERBOSE, EBlockType.TRIGGER, "TaskQueue", $"PriorityTask[{clone.Source}]: '{clone.GetType().Name}' is processed!" +
					 $"'{clone.Source.Card.Text?.Replace("\n", " ")}'");

			// power block
			if (controller.Game.HistoryEnabled)
				controller.Game.PowerHistory.Add(PowerHistoryBuilder.BlockStart(EBlockType.POWER, source.Id, "", -1, target?.Id ?? 0));

			clone.Process();

			if (controller.Game.HistoryEnabled)
				controller.Game.PowerHistory.Add(PowerHistoryBuilder.BlockEnd());

			Game.TaskStack.Reset();
		}

		/// <summary>
		/// Enqueue tasks that will be proccess by the DeathAndAuraProcessing.
		/// IMPORTANT: only enqueue cloned tasks!
		/// </summary>
		/// <param name="task"></param>
		public void Enqueue(ISimpleTask task)
		{
			// TODO ... check if necessary ... frothing beserker ... check for duplicates, ex. auras
			//if (_lazyTaskQueue.Contains(task))
			//    return;

			// TODO reset task from previous uses .. maybee need to clone it?
			//task.Reset();

			_internalList.Add(task.Source.OrderOfPlay, task);
		}

		/// <summary>Processes the next pending task, stored within this queue.</summary>
		/// <returns></returns>
		public ETaskState Process()
		{
			// Retrieve and remove the next task from internal list.
			InternalTaskModel nextTask = _internalList.ElementAtOrDefault(0);
			// Fast-path out if there is no next task to process
			if (nextTask.Equals(default(InternalTaskModel))) return ETaskState.COMPLETE;

			int currentTaskOOP = nextTask.Key;
			CurrentTask = nextTask.Value;
			_internalList.Remove(currentTaskOOP);
			Game.Log(ELogLevel.VERBOSE, EBlockType.TRIGGER, "TaskQueue", $"LazyTask[{CurrentTask.Source}]: '{CurrentTask.GetType().Name}' is processed!" +
										$"'{CurrentTask.Source.Card.Text?.Replace("\n", " ")}'");


			// power block
			if (Game.HistoryEnabled)
				Game.PowerHistory.Add(PowerHistoryBuilder.BlockStart(EBlockType.POWER, CurrentTask.Source.Id, "", -1, CurrentTask.Target?.Id ?? 0));

			ETaskState success = CurrentTask.Process();

			if (Game.HistoryEnabled)
				Game.PowerHistory.Add(PowerHistoryBuilder.BlockEnd());

			// reset between task execution
			Game.TaskStack.Reset();

			//if (Game.Splits.Count == 0 && CurrentTask.Splits != null && CurrentTask.Splits.Count > 0)
			//{
			//    Log.Info($"Parallel-threading splits '{CurrentTask.Splits.Count}' starting now! [Info: {Game.Splits.Count}]");
			//    Game.Splits = CurrentTask.Splits;                
			//}
			return success;
		}

		/// <summary>
		/// Copy internal data from the provided object into this one.
		/// </summary>
		/// <param name="other">The other <see cref="TaskQueue"/> instance.</param>
		public void Stamp(TaskQueue other)
		{
			foreach (KeyValuePair<int, ISimpleTask> kv in other._internalList)
			{
				int taskOOP = kv.Key;
				ISimpleTask clonedTask = kv.Value.Clone();
				clonedTask.Game = Game;

				_internalList.Add(taskOOP, clonedTask);
			}

			if (other.CurrentTask != null)
			{
				CurrentTask = other.CurrentTask.Clone();
				CurrentTask.Game = Game;
			}
		}
	}
}

using SabberStoneCore.Collections;
using SabberStoneCore.Enchants;
using SabberStoneCore.Enums;
using SabberStoneCore.Exceptions;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SabberStoneCore.Model
{
	/// <summary>
	/// Interface of an abstract area where <see cref="IEntity"/> objects
	/// reside.
	/// A zone is owned by a controller and isn't shared.
	/// </summary>
	public interface IZone
	{
		/// <summary>Gets the maximum amount of entities this zone can hold.</summary>
		/// <value>The maximum size.</value>
		int MaxSize { get; }

		/// <summary>Gets a value indicating whether this zone is full. <seealso cref="MaxSize"/></summary>
		/// <value><c>true</c> if this zone reach the maximum amount of entities; otherwise, <c>false</c>.</value>
		/// <autogeneratedoc />
		bool IsFull { get; }

		/// <summary>Gets a value indicating whether this contains entities or not.</summary>
		/// <value><c>true</c> if this zone is empty; otherwise, <c>false</c>.</value>
		/// <autogeneratedoc />
		bool IsEmpty { get; }

		/// <summary>Gets the amount of entities residing in this zone.</summary>
		/// <value>The count of entities.</value>
		int Count { get; }

		/// <summary>Gets the owner of the zone.</summary>
		/// <value>The controller.</value>
		Controller Controller { get; }

		/// <summary>Gets the kind of zone.</summary>
		/// <value><see cref="EZone"/></value>
		/// <autogeneratedoc />
		EZone Type { get; }

		/// <summary>Gets the <see cref="IPlayable"/> with the specified zone position.</summary>
		/// <value>The <see cref="IPlayable"/>.</value>
		/// <param name="zonePosition">The position inside the zone.</param>
		/// <returns></returns>
		IPlayable this[int zonePosition] { get; }

		/// <summary>Gets all entities in this zone.</summary>
		/// <value>The set of <see cref="IPlayable"/>.</value>
		/// <autogeneratedoc />
		IReadOnlyOrderedSet<IPlayable> GetAll { get; }

		/// <summary>Adds the specified entity into this zone, at the given position.</summary>
		/// <param name="entity">The entity.</param>
		/// <param name="zonePosition">The zone position.</param>
		/// <returns>The entity</returns>
		IPlayable Add(IPlayable entity, int zonePosition = -1);

		/// <summary>Removes the specified entity from this zone.</summary>
		/// <param name="entity">The entity.</param>
		/// <returns>The entity.</returns>
		IPlayable Remove(IPlayable entity);

		/// <summary>Replaces the specified entity with another one.</summary>
		/// <param name="oldEntity">The old entity.</param>
		/// <param name="newEntity">The new entity.</param>
		/// <returns>The old entity</returns>
		IPlayable Replace(IPlayable oldEntity, IPlayable newEntity);

		/// <summary>Moves the specified entity to a new position.</summary>
		/// <param name="entity">The entity.</param>
		/// <param name="zonePosition">The zone position.</param>
		void MoveTo(IPlayable entity, int zonePosition);

		/// <summary>Swaps the positions of both entities in this zone.
		/// Both entities must be contained by this zone.
		/// </summary>
		/// <param name="oldEntity">The one entity.</param>
		/// <param name="newEntity">The other entity.</param>
		void Swap(IPlayable oldEntity, IPlayable newEntity);

		/// <summary>Gets the list of enchantments attached to this zone.</summary>
		/// <value>The list of enchantments.</value>
		IList<Enchant> Enchants { get; }
		/// <summary>Gets the list of triggers attacked to this zone.</summary>
		/// <value>The list of triggers.</value>
		/// <autogeneratedoc />
		IList<Trigger> Triggers { get; }

		/// <summary>Copy data from the specified zone into this one.</summary>
		/// <param name="zone">The other zone object.</param>
		void Stamp(IZone zone);

		/// <summary>Returns a string which contains a hash unique to this zone object.</summary>
		/// <param name="ignore">The <see cref="EGameTag"/>s to ignore during hash creation.</param>
		/// <returns></returns>
		string Hash(params EGameTag[] ignore);
	}

	/// <summary>
	/// Base implementation of IZone.
	/// </summary>
	/// <typeparam name="T"></typeparam>
	/// <seealso cref="SabberStoneCore.Model.IZone" />
	/// <seealso cref="System.Collections.Generic.IEnumerable{T}" />
	/// <autogeneratedoc />
	public class Zone<T> : IZone, IEnumerable<T> where T : IPlayable
	{
		#region PROPERTIES

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public Game Game { get; }

		public Controller Controller { get; }

		public EZone Type { get; }

		public int MaxSize => Type == EZone.PLAY
			? Game.MaxMinionsOnBoard
			: (Type == EZone.HAND
				? Controller.MaxHandSize
				: 9999);

		public bool IsFull => !(Count < MaxSize);

		public bool IsEmpty => Count == 0;

		public int Count => _entitiesAsList.Count;

		public T Random => Util.Choose(_entitiesAsList);

		private readonly List<T> _entitiesAsList = new List<T>();

		public IList<Enchant> Enchants { get; } = new List<Enchant>();

		public IList<Trigger> Triggers { get; } = new List<Trigger>();

		public IReadOnlyOrderedSet<IPlayable> GetAll
		{
			get
			{
				return LightWeightOrderedSet<IPlayable>.Build(_entitiesAsList.Cast<IPlayable>());
			}
		}

		public IPlayable this[int zonePosition]
		   => zonePosition >= 0 && zonePosition < _entitiesAsList.Count ? _entitiesAsList[zonePosition] : default(T);

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

		#endregion

		/// <summary>Builds a new zone object.</summary>
		/// <param name="game">The game which contains the zone.</param>
		/// <param name="controller">The controller which owns the zone.</param>
		/// <param name="type">The kind of zone.</param>
		public Zone(Game game, Controller controller, EZone type)
		{
			Game = game;
			Controller = controller;
			Type = type;
			Game.Log(ELogLevel.VERBOSE, EBlockType.PLAY, "Zone", $"Created Zone {type} in Game with Controller {controller.Name}");
		}

		#region IZONE_IMPLEMENTATION

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public IPlayable Add(IPlayable entity, int zonePosition = -1)
		{
			if (zonePosition > _entitiesAsList.Count)
			{
				throw new ZoneException("Zoneposition '" + zonePosition + "' isn't in a valid range.");
			}

			// reset the card if it gets into the graveyard ...
			if (Type == EZone.GRAVEYARD)
				entity.Reset();

			MoveTo(entity, zonePosition < 0 ? _entitiesAsList.Count : zonePosition);
			Game.Log(ELogLevel.DEBUG, EBlockType.PLAY, "Zone", $"Entity '{entity} ({entity.Card.Type})' has been added to zone '{Type}' in position '{entity.ZonePosition}'.");

			// activate all zone changing enchantments
			entity.ApplyEnchantments(EEnchantmentActivation.SETASIDE, EZone.SETASIDE);
			entity.ApplyEnchantments(EEnchantmentActivation.BOARD, EZone.PLAY);
			entity.ApplyEnchantments(EEnchantmentActivation.HAND, EZone.HAND);
			entity.ApplyEnchantments(EEnchantmentActivation.DECK, EZone.DECK);

			entity.SetOrderOfPlay(Type.ToString());
			return entity;
		}

		public IPlayable Remove(IPlayable entity)
		{
			if (!_entitiesAsList.Remove((T)entity))
			{
				throw new ZoneException("Couldn't remove entity from zone.");
			}
			RePosition(entity.ZonePosition);
			entity.Zone = null;
			//entity[GameTag.ZONE] = (int) Zone.INVALID;
			//entity.ZonePosition = 0;
			return entity;
		}

		public void MoveTo(IPlayable entity, int zonePosition)
		{
			_entitiesAsList.Insert(zonePosition, (T)entity);
			entity.Zone = this;
			entity[EGameTag.ZONE] = (int)Type;
			RePosition(zonePosition);
		}

		public IPlayable Replace(IPlayable oldEntity, IPlayable newEntity)
		{
			MoveTo(newEntity, _entitiesAsList.Count);
			Swap(oldEntity, newEntity);
			return Remove(oldEntity);
		}

		public void Swap(IPlayable oldEntity, IPlayable newEntity)
		{
			if (oldEntity.Zone != newEntity.Zone)
			{
				throw new ZoneException("Swap not possible because of zone missmatch.");
			}

			int oldPos = oldEntity.ZonePosition;
			int newPos = newEntity.ZonePosition;
			newEntity.ZonePosition = oldPos;
			oldEntity.ZonePosition = newPos;
			_entitiesAsList[newPos] = (T)oldEntity;
			_entitiesAsList[oldPos] = (T)newEntity;
		}

		private void RePosition(int zonePosition = 0)
		{
			for (int i = zonePosition; i < _entitiesAsList.Count; i++)
			{
				_entitiesAsList[i].ZonePosition = i;
			}
		}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
		#endregion

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public override string ToString()
		{
			return $"[ZONE {Type} '{Controller.Name}']";
		}

		public IEnumerator<T> GetEnumerator()
		{
			return _entitiesAsList.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public string FullPrint()
		{
			var str = new StringBuilder();
			str.Append($"{this}|");
			_entitiesAsList.ForEach(p =>
			{
				var m = p as Minion;
				var w = p as Weapon;
				var mStr = m != null ? $"[{m.AttackDamage}/{m.Health}]" : (w != null ? $"[{w.AttackDamage}/{w.Durability}]" : "");
				str.Append($"[P{p.ZonePosition}]{mStr}[C{p.Cost}]{p}|");
			});
			str.Append($"[ENCH {Enchants.Count}]");
			str.Append($"[TRIG {Triggers.Count}]");
			return str.ToString();
		}

		public void Stamp(IZone zone)
		{
			zone.GetAll.ToList().ForEach(p =>
			{
				var copy = Entity.FromCard(Controller, p.Card, null, null, p.Id);
				copy.Stamp(p as Entity);
				MoveTo(copy, copy.ZonePosition);
			});
			zone.Enchants.ForEach(p => Enchants.Add(p.Copy(p.SourceId, Game, p.Turn, Enchants, p.Owner, p.RemoveTriggers)));
			zone.Triggers.ForEach(p => Triggers.Add(p.Copy(p.SourceId, Game, p.Turn, Triggers, p.Owner)));
		}

		public string Hash(params EGameTag[] ignore)
		{
			var str = new StringBuilder();
			str.Append("[Z:");
			str.Append($"{Type}");
			str.Append("][E:");
			IOrderedEnumerable<IPlayable> list = GetAll;
			if (Type != EZone.PLAY)
			{
				list = list.OrderBy(p => p.Id);
				Array.Resize(ref ignore, ignore.Length + 1);
				ignore[ignore.Length - 1] = EGameTag.ZONE_POSITION;
			}
			list.ForEach(p => str.Append(p.Hash(ignore)));
			str.Append($"][EN:{Enchants.Count}");
			Enchants.ForEach(p => str.Append(p.Hash));
			str.Append($"][TR:{Triggers.Count}");
			Triggers.ForEach(p => str.Append(p.Hash));
			str.Append("]");
			return str.ToString();
		}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	}
}